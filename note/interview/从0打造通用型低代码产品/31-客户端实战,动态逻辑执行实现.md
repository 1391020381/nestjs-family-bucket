# 实现思路
* 在浏览器当中执行字符串代码是一个比较危险的方。通常来说,使用以下两个手段可以在浏览器中执行字符串代码片段。
1. Function: Function是JavaScript中的一个内置对象,它可以将一个字符串转化为一个函数 并执行该函数。例如 可以使用如下代码来执行字符串代码片段。

```
const code = "console.log('Hello, world!');";
var func = new Function(code);
func();

```
2. eval: eval是JavaScript中的一个内置函数,它可以直接执行一段字符串代码,并返回执行结果。例如可以使用如下代码来执行字符串代码片段：

```
const code = "console.log('Hello, world!');";
eval(code);


```

* vue react 等模版,解析动态 表达式 或方法 再调用  上面的方法来执行。
* Function window.eval 都可以执行低代码片段,在实际应用中,应该根据具体的场景和需求来选择最合适的执行方式。 
* 在 @Ignition-lowcode/core   jsRuntime.ts 
* 执行代码的方案有了后,需要考虑一些其他条件因素了:
    - 浏览器兼容性
    - 安全性  XSS漏洞   整个上下文收敛在到沙盒中 避免用户操作非法代码造成安全问题。
    - 执行速度  从交互层面来引导用户应尽可能地避免重复的代码执行,把相同的操作集中在一起等。
    - 单例模式  在全局上下文 开发人员可以使用单例模式来保证有且只有一个执行容器存在,这样避免频繁创建容器而未销毁的情况。这样能避免一些常见的浏览器崩溃 或 变慢的问题。


![动态逻辑](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/086606b695b541efabe290deb7136a8d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)    

# 实现过程



```
// 页面使用
export function withMaterialNode<T = any> (WrapComponent: React.FunctionComponent<T>) {
  return function (props: any) {
    const { connectors: { connect, drag } } = useNode()

+    const memoizedProps = React.useMemo(() => {
+      const cloneProps =  cloneDeepWith(props,  (value) => {
+        // vm run
+        if (value && typeof value === "string" && isExpression(value)) {
+          console.log(`执行代码： ${value}`)
+          return browserRuntimeVM.execute(parseJsStrToLte(value), {props})?.value
+        }
+      })
+      return cloneProps
+    }, [props])

    return (
      <ErrorBoundary fallbackRender={fallbackRender} >
        <WrapComponent ref={(dom: HTMLElement) => connect(drag(dom))} {...memoizedProps}/>
      </ErrorBoundary>
    )
  }
}


```

# 总结
* 通过组件属性动态逻辑绑定执行能力,实现了BrowserRuntimeVM类,能够在页面中动态执行逻辑。
* 为了保证其稳定性并避免与应用上下文的串联带来问题,考虑了安全性与灵活性,为其提供了一个独立的上下文容器,通过iframe的sandbox来实现。
* 还实现了 解析表达式的相关逻辑,通过快速判断表达式并将其转换为模版字符串,使其能够执行相关的获取逻辑,并将结果展示在组件中。