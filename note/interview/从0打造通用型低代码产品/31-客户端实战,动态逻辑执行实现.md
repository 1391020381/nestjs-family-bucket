# 实现思路
* 在浏览器当中执行字符串代码是一个比较危险的方。通常来说,使用以下两个手段可以在浏览器中执行字符串代码片段。
1. Function: Function是JavaScript中的一个内置对象,它可以将一个字符串转化为一个函数 并执行该函数。例如 可以使用如下代码来执行字符串代码片段。

```
const code = "console.log('Hello, world!');";
var func = new Function(code);
func();

```
2. eval: eval是JavaScript中的一个内置函数,它可以直接执行一段字符串代码,并返回执行结果。例如可以使用如下代码来执行字符串代码片段：

```
const code = "console.log('Hello, world!');";
eval(code);


```

* vue react 等模版,解析动态 表达式 或方法 再调用  上面的方法来执行。
* Function window.eval 都可以执行低代码片段,在实际应用中,应该根据具体的场景和需求来选择最合适的执行方式。 
* 在 @Ignition-lowcode/core   jsRuntime.ts 
* 执行代码的方案有了后,需要考虑一些其他条件因素了:
    - 浏览器兼容性
    - 安全性  XSS漏洞   整个上下文收敛在到沙盒中 避免用户操作非法代码造成安全问题。
    - 执行速度  从交互层面来引导用户应尽可能地避免重复的代码执行,把相同的操作集中在一起等。
    - 单例模式  在全局上下文 开发人员可以使用单例模式来保证有且只有一个执行容器存在,这样避免频繁创建容器而未销毁的情况。这样能避免一些常见的浏览器崩溃 或 变慢的问题。


![动态逻辑](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/086606b695b541efabe290deb7136a8d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)    

# 实现过程



```
// 页面使用
export function withMaterialNode<T = any> (WrapComponent: React.FunctionComponent<T>) {
  return function (props: any) {
    const { connectors: { connect, drag } } = useNode()

+    const memoizedProps = React.useMemo(() => {
+      const cloneProps =  cloneDeepWith(props,  (value) => {
+        // vm run
+        if (value && typeof value === "string" && isExpression(value)) {
+          console.log(`执行代码： ${value}`)
+          return browserRuntimeVM.execute(parseJsStrToLte(value), {props})?.value
+        }
+      })
+      return cloneProps
+    }, [props])

    return (
      <ErrorBoundary fallbackRender={fallbackRender} >
        <WrapComponent ref={(dom: HTMLElement) => connect(drag(dom))} {...memoizedProps}/>
      </ErrorBoundary>
    )
  }
}


```

# 总结
* 通过组件属性动态逻辑绑定执行能力,实现了BrowserRuntimeVM类,能够在页面中动态执行逻辑。
* 为了保证其稳定性并避免与应用上下文的串联带来问题,考虑了安全性与灵活性,为其提供了一个独立的上下文容器,通过iframe的sandbox来实现。
* 还实现了 解析表达式的相关逻辑,通过快速判断表达式并将其转换为模版字符串,使其能够执行相关的获取逻辑,并将结果展示在组件中。

* 将要注入的全局变量 globalScope 设置到 sandbox对象中 __INJECT_VARS__ 属性中,从而容器内部创建一个与外部JavaScript代码同名的全局对象。
* 然后,将JavaScript代码字符串传递到 iframe中的 eval() 函数中执行。 在执行代码之前,容器通过使用JavaScript语句 with(window.INJECT_VARS) 建立了一个新的作用域,用于包含注入的全局变量。
* with语句允许代码中的所有变量名直接使用容器内的全局变量进行匹配,这就意味外部JavaScript代码将使用与容器中同名的全局变量,而不是使用同名的变量本身。

* 组件(jsonschema)  withMaterialNode(ButtonView) 编辑器组件    
* withMaterialNode props发生变化的时候,通过 cloneDeepWith方法深度遍历每个属性,通过 isExpression 判断 value 如果为表达式的情况下，将其调用 parseJsStrToLte 的结果给 browserRuntimeVM.execute 执行，此时将原始的 props 传递给 browserRuntimeVM 创造当前的上下文。
* 最后将 cloneDeepWith 返回的新对象 memoizedProps 传递给组件进行渲染，此时就会发现 props.text 的内容已经发生了改变。


# 低代码-- 自定义事件和状态 
1. jsonschema  事件和状态设置
2. iframe evl 可以动态执行js代码 且 传入了全局上下文(可以获取 vue react一些 api 来定义事件状态)
3. 编辑器组件 包一层HOC 如果props改变 就重新执行 eval动态执行代码
4. 编译产物 将定义的 js state 进行混合。最后还是vue react原生代码？

```


let vueAPI = {
    // 这里可以是从全局Vue对象中提取的更多东西
    ref: Vue.ref,
    //...
};

// 用户代码
let userCode = `
    let a = ref(0);
    const b = function(){
        console.log(2323);
        console.log(a.value)
    };
`;

// 通过with注入Vue的API并执行用户的代码
with (vueAPI) {
    eval(userCode);
}


// 视图
{
  type:"button",
  setting:{
    onClick:()=>{}
  }
}
<button>按钮</button>

// 属性编辑 
{
  type:"button",
  setting:{
    onClick:b
  }
}
// 编辑器 props变化   事件  eval执行  b()

// 产物 用户代码混合进入 对应组件中？
```



```

import { createApp, ref, h, watch, defineComponent } from 'vue';

const vueAPI = { ref };

let userCode = `
let a = ref(0);
const b = function() {
  console.log(2323);
  console.log(a.value);
  a.value++;
};
`;

const props = { onClick: null };

with (vueAPI) {
  let localVar;
  const declareHelper = (name, value) => {
    vueAPI[name] = value;
    localVar = { ...localVar, ...{ [name]: value } };
  };
  new Function('declare', userCode)(declareHelper);

  // 更新属性
  props.onClick = localVar.b;
}

// 原始组件
const ButtonComponent = {
  props: ['onClick'],
  render() {
    return h('button', { onClick: this.onClick }, '按钮');
  },
};

// 高阶组件，监测props的变化
const withPropsWatcher = (Component) => {
  return defineComponent({
    props: Component.props,
    setup(props) {
      // 观察 props 变化
      watch(() => props, (newValue) => {
        console.log('Props 更新了，新的值是：', newValue);
        // 在这里可以进行处理props改变后的操作
      }, { deep: true });

      return () => h(Component, props);
    },
  });
};

// 生成新的组件
const EnhancedButton = withPropsWatcher(ButtonComponent);

// 创建并挂在Vue应用
const vueApp = createApp(EnhancedButton, props);
const app = vueApp.mount('#app');



procode // 产物中 直接使用 prop渲染 ButtonComponent 并混入  userCode

```